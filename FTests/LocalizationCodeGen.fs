module FTests.LocalizationCodeGen
open System
open FTests.Utils
open FTests.Extensions
open LocalizationExecutor.LocalizationCodeGen

open NUnit.Framework

[<SetUp>]
let Setup () =
    ()
    
let ctx: LGenCtx = {
    localeSwitch = "Localization.Locale"
    objectType = "ILangObject"
    locales = ["EN"; "JP"]
    lsclass = None
    methodToLsSuffix = None
    lsGenerated = []
    errors = []
    renderFunc = "Render"
    funcStandardizer = id
    className = "LocalizedStrings"
    nestedClassName = "General"
    namespace_ = "DMK.Core"
    outputHeader = "//This is AUTOGENERATED CODE. Edits may be overwritten at any time."
    lskeyprefix = "" }
let lsctx = { ctx with lsclass = Some ("LocalizedString", "LocalizedString") }
let lsdctx = { lsctx with methodToLsSuffix = Some "__ls" }
    
let TestEq(ctx, row, (expect: String)) =
    let csets = ctx.locales |> List.map (fun _ -> Set.empty)
    let (_, ctx, parse) = generateRow csets ctx row
    Assert.AreEqual(expect.Replace("\r\n", "\n"), render parse 0 |> (fun x -> x.Trim()))

[<Test>]
let TestBasic() =
    let row = {
        key = "pickup_50_gold"
        en = "gold {$PLURAL(1, coin, coins)}"
        jp = "{0}が金貨を{$JP_COUNTER(1, 枚)}拾いました"
    }
    TestEq(ctx, row, """public static string pickup_50_gold(ILangObject arg0, ILangObject arg1) => Localization.Locale switch {
	JP => Render(Localization.Locale, new[] {
		"{0}",
		"が金貨を",
		JP_COUNTER(arg1, "枚"),
		"拾いました",
	}, arg0, arg1),
	_ => Render(Localization.Locale, new[] {
		"gold ",
		PLURAL(arg1, "coin", "coins"),
	}, arg0, arg1),
};""")


[<Test>]
let TestMissing() =
    let csets = ctx.locales |> List.map (fun _ -> Set.empty)
    let row = {
        key = "ex.missing"
        en = "en!"
        jp = "jp!"
    }
    TestEq(ctx, row, """public static string ex_missing => Localization.Locale switch {
	JP => "jp!",
	_ => "en!",
};""")
    
    let row = {
        key = "ex_missing"
        en = "en!"
        jp = "{"
    }
    Assert.AreEqual((generateRow csets ctx row |> (fun (_, x, _) -> x)).errors.Length, 1)
    TestEq(ctx, row, """public static string ex_missing => Localization.Locale switch {
	_ => "en!",
};""")
    TestEq(lsctx, row, """public static readonly LocalizedString ex_missing = new LocalizedString("en!")
	{ ID = "ex_missing" };""")
    
[<Test>]
let TestSuffix() =
    let row = {
        key = "hello_world"
        en = "a{0}"
        jp = "{0}b"
    }
    TestEq(lsdctx, row, """public static string hello_world(ILangObject arg0) => Localization.Locale switch {
	JP => Render(Localization.Locale, new[] {
		"{0}",
		"b",
	}, arg0),
	_ => Render(Localization.Locale, new[] {
		"a",
		"{0}",
	}, arg0),
};

public static LocalizedString hello_world__ls(ILangObject arg0) => new LocalizedString(Render(EN, new[] {
		"a",
		"{0}",
	}, arg0),
	(JP, Render(JP, new[] {
		"{0}",
		"b",
	}, arg0)))
	{ ID = "hello_world" };""")
    
    